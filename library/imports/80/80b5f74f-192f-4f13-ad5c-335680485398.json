{
  "__type__": "cc.EffectAsset",
  "_name": "Background",
  "_objFlags": 0,
  "_native": "",
  "properties": null,
  "techniques": [
    {
      "passes": [
        {
          "blendState": {
            "targets": [
              {
                "blend": true
              }
            ]
          },
          "rasterizerState": {
            "cullMode": 0
          },
          "properties": {
            "time": {
              "value": [
                0.5
              ],
              "type": 13
            }
          },
          "program": "Background|vs|fs"
        }
      ]
    }
  ],
  "shaders": [
    {
      "hash": 1947898147,
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nin vec2 a_uv0;\nout vec2 v_uv0;\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matViewProj * pos;\n  v_uv0 = a_uv0;\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\n#if USE_GL_OES_STANDARD\n  #extension GL_OES_standard_derivatives : enable\n#endif\nprecision highp float;\nin vec4 v_color;\nin vec2 v_uv0;\nuniform TIME {\n  float time;\n};\nfloat hash11(float p) {\n  vec3 p3  = fract(vec3(p) * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash12(vec2 p) {\n  vec3 p3  = fract(vec3(p.xyx) * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat within(float a, float b, float t) {\n  return (t-a) / (b-a);\n}\nfloat skewbox(vec2 uv, vec3 top, vec3 bottom, float blur) {\n  float y = within(top.z, bottom.z, uv.y);\n    float left = mix(top.x, bottom.x, y);\n    float right = mix(top.y, bottom.y, y);\n    float horizontal = smoothstep(left,left+blur,uv.x)*smoothstep(right+blur,right,uv.x);\n    float vertical = smoothstep(bottom.uv.y,bottom.uv.y+blur,uv.y)*smoothstep(top.uv.y+blur,top.uv.y,uv.y);\n    return horizontal*vertical;\n}\nvec4 pine(vec2 uv, vec2 p, float s, float focus) {\n  uv.x -= .5;\n    float c = skewbox(uv, vec3(.0, .0, 1.), vec3(-.14, .14, .65), focus);\n    c += skewbox(uv, vec3(-.10, .10, .65), vec3(-.18, .18, .43), focus);\n    c += skewbox(uv, vec3(-.13, .13, .43), vec3(-.22, .22, .2), focus);\n    c += skewbox(uv, vec3(-.04, .04, .2), vec3(-.04, .04, -.1), focus);\n    vec4 col = vec4(1.,1.,1.,0.);\n    col.a = c;\n    float shadow = skewbox(uv.yx, vec3(.6, .65, .13), vec3(.65, .65, -.1), focus);\n    shadow += skewbox(uv.yx, vec3(.43, .43, .13), vec3(.36, .43, -.2), focus);\n    shadow += skewbox(uv.yx, vec3(.15, .2, .08), vec3(.17, .2, -.08), focus);\n    col.rgb = mix(col.rgb, col.rgb*.8, shadow);\n    return col;\n}\nfloat getheight(float x) {\n    return sin(x) + sin(x*2.234+.123)*.5 + sin(x*4.45+2.2345)*.25;\n}\nvec4 landscape(vec2 uv, float d, float p, float f, float a, float y, float seed, float focus) {\n    uv *= d;\n    float x = uv.x*3.1415*f+p;\n    float c = getheight(x)*a+y;\n    float b = floor(x*5.)/5.+.1;\n    float h =  getheight(b)*a+y;\n    #if USE_GL_OES_STANDARD\n      float e = fwidth(uv.y);\n    #else\n      float e = uv.y/2.;\n    #endif\n    vec4 col = vec4(smoothstep(c+e,c-e,uv.y));\n    x *= 5.;\n    float id = floor(x);\n    float n = hash11(id+seed);\n    x = fract(x);\n    y = (uv.y - h)*mix(5., 3., n)*3.5;\n    float treeHeight = (.07/d) * mix(1.3, .5, n);\n    y = within(h, h+treeHeight, uv.y);\n    x += (n-.5)*.6;\n    vec4 pineCol = pine(vec2(x, y/d), vec2(0.), 1., focus+d*.1);\n    col.rgb = mix(col.rgb, pineCol.rgb, pineCol.a);\n    col.a = max(col.a, pineCol.a);\n    return clamp(col,0.,1.);\n}\nvec4 gradient(vec2 uv) {\n  float c = 1.-length(vec2(1.3, .8)-uv)/1.4;\n    vec4 col = vec4(c);\n    return col;\n}\nfloat circ(vec2 uv, vec2 pos, float radius, float blur) {\n  float dist = length(uv-pos);\n  return smoothstep(radius+blur,radius-blur,dist);\n}\nvec4 moon(vec2 uv) {\n    float c = circ(uv, vec2(1.3, .8), .07, .001);\n    c *= 1.-circ(uv, vec2(1.3, .8)+vec2(.03), .07, .001)*.95;\n    c = clamp(c,0.,1.);\n    vec4 col = vec4(c);\n    col.rgb *=.8;\n    return col;\n}\nvec4 moonglow(vec2 uv, float foreground) {\n    float c = circ(uv, vec2(1.3, .8), .1, .2);\n    vec4 col = vec4(c);\n    col.rgb *=.2;\n    return col;\n}\nfloat stars(vec2 uv, float t) {\n    t*=3.;\n    float n1 = hash12(uv*10000.);\n    float n2 = hash12(uv*11234.);\n    float alpha1 = pow(n1, 20.);\n    float alpha2 = pow(n2, 20.);\n    float twinkle = sin((uv.x-t+cos(uv.y*20.+t))*10.);\n    twinkle *= cos((uv.y*.234-t*3.24+sin(uv.x*12.3+t*.243))*7.34);\n    twinkle = (twinkle + 1.)/2.;\n    return alpha1 * alpha2 * twinkle;\n}\nvoid main () {\n  vec2 uv = vec2(1.0-v_uv0.x, v_uv0.y);\n  float t = time*.05;\n  vec2 bgUV = uv*vec2(1.5, 1.);\n  vec4 col = gradient(bgUV)*.8;\n  col += moon(bgUV);\n  col += stars(uv, t);\n  float dist = .10;\n  float height = -.01;\n  float amplitude = .02;\n  dist = 1.;\n  height = .55;\n  vec4 trees = vec4(0.);\n  for(float i=0.; i<10.; i++) {\n    vec4 layer = landscape(uv, dist, t+i, 3., amplitude, height, i, .01);\n    layer.rgb *= mix(vec3(.1, .1, .2), vec3(.3)+gradient(uv).x, 1.-i/10.);\n      trees = mix(trees, layer, layer.a);\n      dist -= .1;\n      height -= .06;\n  }\n  col = mix(col, trees, trees.a);\n  col += moonglow(bgUV, 1.);\n  col = clamp(col,0.,1.);\n  vec4 foreground = landscape(uv, .02, t, 3., .0, -0.08, 1., .1);\n  foreground.rgb *= vec3(.1, .1, .2)*.5;\n  col = mix(col, foreground, foreground.a);\n  gl_FragColor = vec4(col);\n}"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matViewProj * pos;\n  v_uv0 = a_uv0;\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\n#if USE_GL_OES_STANDARD\n  #extension GL_OES_standard_derivatives : enable\n#endif\nprecision highp float;\nvarying vec4 v_color;\nvarying vec2 v_uv0;\nuniform float time;\nfloat hash11(float p) {\n  vec3 p3  = fract(vec3(p) * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash12(vec2 p) {\n  vec3 p3  = fract(vec3(p.xyx) * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat within(float a, float b, float t) {\n  return (t-a) / (b-a);\n}\nfloat skewbox(vec2 uv, vec3 top, vec3 bottom, float blur) {\n  float y = within(top.z, bottom.z, uv.y);\n    float left = mix(top.x, bottom.x, y);\n    float right = mix(top.y, bottom.y, y);\n    float horizontal = smoothstep(left,left+blur,uv.x)*smoothstep(right+blur,right,uv.x);\n    float vertical = smoothstep(bottom.uv.y,bottom.uv.y+blur,uv.y)*smoothstep(top.uv.y+blur,top.uv.y,uv.y);\n    return horizontal*vertical;\n}\nvec4 pine(vec2 uv, vec2 p, float s, float focus) {\n  uv.x -= .5;\n    float c = skewbox(uv, vec3(.0, .0, 1.), vec3(-.14, .14, .65), focus);\n    c += skewbox(uv, vec3(-.10, .10, .65), vec3(-.18, .18, .43), focus);\n    c += skewbox(uv, vec3(-.13, .13, .43), vec3(-.22, .22, .2), focus);\n    c += skewbox(uv, vec3(-.04, .04, .2), vec3(-.04, .04, -.1), focus);\n    vec4 col = vec4(1.,1.,1.,0.);\n    col.a = c;\n    float shadow = skewbox(uv.yx, vec3(.6, .65, .13), vec3(.65, .65, -.1), focus);\n    shadow += skewbox(uv.yx, vec3(.43, .43, .13), vec3(.36, .43, -.2), focus);\n    shadow += skewbox(uv.yx, vec3(.15, .2, .08), vec3(.17, .2, -.08), focus);\n    col.rgb = mix(col.rgb, col.rgb*.8, shadow);\n    return col;\n}\nfloat getheight(float x) {\n    return sin(x) + sin(x*2.234+.123)*.5 + sin(x*4.45+2.2345)*.25;\n}\nvec4 landscape(vec2 uv, float d, float p, float f, float a, float y, float seed, float focus) {\n    uv *= d;\n    float x = uv.x*3.1415*f+p;\n    float c = getheight(x)*a+y;\n    float b = floor(x*5.)/5.+.1;\n    float h =  getheight(b)*a+y;\n    #if USE_GL_OES_STANDARD\n      float e = fwidth(uv.y);\n    #else\n      float e = uv.y/2.;\n    #endif\n    vec4 col = vec4(smoothstep(c+e,c-e,uv.y));\n    x *= 5.;\n    float id = floor(x);\n    float n = hash11(id+seed);\n    x = fract(x);\n    y = (uv.y - h)*mix(5., 3., n)*3.5;\n    float treeHeight = (.07/d) * mix(1.3, .5, n);\n    y = within(h, h+treeHeight, uv.y);\n    x += (n-.5)*.6;\n    vec4 pineCol = pine(vec2(x, y/d), vec2(0.), 1., focus+d*.1);\n    col.rgb = mix(col.rgb, pineCol.rgb, pineCol.a);\n    col.a = max(col.a, pineCol.a);\n    return clamp(col,0.,1.);\n}\nvec4 gradient(vec2 uv) {\n  float c = 1.-length(vec2(1.3, .8)-uv)/1.4;\n    vec4 col = vec4(c);\n    return col;\n}\nfloat circ(vec2 uv, vec2 pos, float radius, float blur) {\n  float dist = length(uv-pos);\n  return smoothstep(radius+blur,radius-blur,dist);\n}\nvec4 moon(vec2 uv) {\n    float c = circ(uv, vec2(1.3, .8), .07, .001);\n    c *= 1.-circ(uv, vec2(1.3, .8)+vec2(.03), .07, .001)*.95;\n    c = clamp(c,0.,1.);\n    vec4 col = vec4(c);\n    col.rgb *=.8;\n    return col;\n}\nvec4 moonglow(vec2 uv, float foreground) {\n    float c = circ(uv, vec2(1.3, .8), .1, .2);\n    vec4 col = vec4(c);\n    col.rgb *=.2;\n    return col;\n}\nfloat stars(vec2 uv, float t) {\n    t*=3.;\n    float n1 = hash12(uv*10000.);\n    float n2 = hash12(uv*11234.);\n    float alpha1 = pow(n1, 20.);\n    float alpha2 = pow(n2, 20.);\n    float twinkle = sin((uv.x-t+cos(uv.y*20.+t))*10.);\n    twinkle *= cos((uv.y*.234-t*3.24+sin(uv.x*12.3+t*.243))*7.34);\n    twinkle = (twinkle + 1.)/2.;\n    return alpha1 * alpha2 * twinkle;\n}\nvoid main () {\n  vec2 uv = vec2(1.0-v_uv0.x, v_uv0.y);\n  float t = time*.05;\n  vec2 bgUV = uv*vec2(1.5, 1.);\n  vec4 col = gradient(bgUV)*.8;\n  col += moon(bgUV);\n  col += stars(uv, t);\n  float dist = .10;\n  float height = -.01;\n  float amplitude = .02;\n  dist = 1.;\n  height = .55;\n  vec4 trees = vec4(0.);\n  for(float i=0.; i<10.; i++) {\n    vec4 layer = landscape(uv, dist, t+i, 3., amplitude, height, i, .01);\n    layer.rgb *= mix(vec3(.1, .1, .2), vec3(.3)+gradient(uv).x, 1.-i/10.);\n      trees = mix(trees, layer, layer.a);\n      dist -= .1;\n      height -= .06;\n  }\n  col = mix(col, trees, trees.a);\n  col += moonglow(bgUV, 1.);\n  col = clamp(col,0.,1.);\n  vec4 foreground = landscape(uv, .02, t, 3., .0, -0.08, 1., .1);\n  foreground.rgb *= vec3(.1, .1, .2)*.5;\n  col = mix(col, foreground, foreground.a);\n  gl_FragColor = vec4(col);\n}"
      },
      "builtins": {
        "globals": {
          "blocks": [
            {
              "name": "CCGlobal",
              "defines": []
            }
          ],
          "samplers": []
        },
        "locals": {
          "blocks": [
            {
              "name": "CCLocal",
              "defines": []
            }
          ],
          "samplers": []
        }
      },
      "defines": [
        {
          "name": "USE_GL_OES_STANDARD",
          "type": "boolean",
          "defines": []
        }
      ],
      "blocks": [
        {
          "name": "TIME",
          "members": [
            {
              "name": "time",
              "type": 13,
              "count": 1
            }
          ],
          "defines": [],
          "binding": 0
        }
      ],
      "samplers": [],
      "record": null,
      "name": "Background|vs|fs"
    }
  ]
}